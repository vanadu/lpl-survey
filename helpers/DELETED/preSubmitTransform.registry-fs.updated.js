// helpers/preSubmitTransform.js
//
// Authoritative schema source (NO fallback):
//   - helpers/registry.generated.json (generated by merge-surveys.js)
//
// Goals:
// - Enforce schema order + null-fill missing fields using registry as the single source of truth.
// - STRICT: throw if incoming survey data contains keys not present in the registry schema
//   (excluding known metadata fields).
//
// Note on JSON imports:
// - We intentionally do NOT `import ... from "./registry.generated.json"` because some Next/Node
//   setups can yield undefined/default-export issues with JSON imports.
// - Instead, we load the JSON from disk at runtime (server-side only).
//

import fs from "fs";
import path from "path";

/** Cache registry between calls (API routes may reuse the same process) */
let _cachedRegistryJson = null;

function loadRegistryJson() {
  if (_cachedRegistryJson) return _cachedRegistryJson;

  const registryPath = path.join(process.cwd(), "helpers", "registry.generated.json");

  if (!fs.existsSync(registryPath)) {
    throw new Error(
      `preSubmitTransform: registry.generated.json not found at ${registryPath}. Run merge-surveys.js first.`
    );
  }

  const txt = fs.readFileSync(registryPath, "utf8").trim();
  if (!txt) {
    throw new Error("preSubmitTransform: registry.generated.json exists but is empty.");
  }

  let parsed;
  try {
    parsed = JSON.parse(txt);
  } catch (e) {
    throw new Error(
      `preSubmitTransform: registry.generated.json is not valid JSON: ${String(e?.message || e)}`
    );
  }

  _cachedRegistryJson = parsed;
  return _cachedRegistryJson;
}

/**
 * Extract schema names from registry.generated.json.
 * Supports common shapes produced by generators:
 * - Array of objects: [{ name: "Q1", ...}, ...]
 * - Array of strings: ["Q1","Q2", ...]
 * - Wrapper object: { registry: [...] } / { items: [...] } / { questions: [...] } / { elements: [...] }
 * - Map object: { byName: { Q1: {...}, Q2: {...} } }
 * - Direct map: { Q1: {...}, Q2: {...} }  (only used if no wrapper arrays exist)
 */
function extractSchemaNames(registryJson) {
  // 1) Array shapes
  if (Array.isArray(registryJson)) {
    // 1a) Array of objects with `name`
    const namesFromObjects = registryJson
      .map((x) => x?.name)
      .filter((n) => typeof n === "string" && n.trim().length > 0);

    if (namesFromObjects.length > 0) return namesFromObjects;

    // 1b) Array of strings
    const namesFromStrings = registryJson.filter(
      (n) => typeof n === "string" && n.trim().length > 0
    );
    if (namesFromStrings.length > 0) return namesFromStrings;

    throw new Error(
      "preSubmitTransform: registry.generated.json is an array but contains no usable schema names."
    );
  }

  // 2) Object shapes
  if (registryJson && typeof registryJson === "object") {
    // 2a) Wrapper arrays
    for (const key of ["registry", "items", "questions", "elements", "schema"]) {
      if (Array.isArray(registryJson[key])) {
        return extractSchemaNames(registryJson[key]);
      }
    }

    // 2b) byName map
    if (registryJson.byName && typeof registryJson.byName === "object") {
      const keys = Object.keys(registryJson.byName).filter((k) => k.trim().length > 0);
      if (keys.length > 0) return keys;
    }

    // 2c) Direct map fallback (still registry-only; no deprecated files)
    // Guard against obvious metadata-only top-level objects.
    const keys = Object.keys(registryJson).filter((k) => k.trim().length > 0);
    const looksLikeMetadataOnly =
      keys.length > 0 &&
      keys.every((k) => ["version", "meta", "generatedAt", "source", "notes"].includes(k));

    if (!looksLikeMetadataOnly && keys.length > 0) {
      return keys;
    }
  }

  throw new Error(
    "preSubmitTransform: registry.generated.json must provide schema names (array, wrapper array, or name map)."
  );
}

/**
 * Transforms SurveyJS result JSON prior to submission.
 * Enforces schema order and null-fills missing fields.
 *
 * STRICT:
 * - throws if incoming survey data contains keys not present in registry-generated schema
 *   (excluding known metadata fields).
 *
 * @param {object} surveyData - Raw SurveyJS data object
 * @returns {object} { metadata, data }
 */
export function preSubmitTransform(surveyData) {
  if (!surveyData || typeof surveyData !== "object") {
    throw new Error("preSubmitTransform: invalid survey data");
  }

  const registryJson = loadRegistryJson();
  const schemaNames = extractSchemaNames(registryJson).filter(
    (n) => typeof n === "string" && n.trim().length > 0
  );

  if (schemaNames.length === 0) {
    throw new Error(
      "preSubmitTransform: registry.generated.json yielded zero schema names (check generator output)."
    );
  }

  // Extract known non-survey fields (metadata / helpers)
  const {
    UserInfoContactType,
    UserInfoContactTypeEmail,
    UserInfoContactTypeFacebook,
    UserInfoFirstName,
    CmpnName,

    // timestamp compatibility: prefer submittedAt if present
    submittedAt,
    completedAt,

    // optional helper metadata (safe to ignore)
    source,
    _meta,

    ...rest
  } = surveyData;

  /* -----------------------------
     Resolve contact identifier (used for filename only)
  ----------------------------- */
  const contact =
    UserInfoContactType === true
      ? UserInfoContactTypeFacebook
      : UserInfoContactTypeEmail || "unknown";

  /* -----------------------------
     Timestamp handling
     - Prefer submittedAt (shared between save + email)
     - Fall back to completedAt
     - Else: now
  ----------------------------- */
  const effectiveDate = submittedAt
    ? new Date(submittedAt)
    : completedAt
    ? new Date(completedAt)
    : new Date();

  if (Number.isNaN(effectiveDate.getTime())) {
    throw new Error(
      "preSubmitTransform: invalid submittedAt/completedAt timestamp (expected ISO string or Date-parsable value)."
    );
  }

  const pad = (n) => String(n).padStart(2, "0");

  // Filename stamp includes seconds (YYYYMMDD_HHMMSS)
  const timestamp = `${effectiveDate.getFullYear()}${pad(
    effectiveDate.getMonth() + 1
  )}${pad(effectiveDate.getDate())}_${pad(effectiveDate.getHours())}${pad(
    effectiveDate.getMinutes()
  )}${pad(effectiveDate.getSeconds())}`;

  /* -----------------------------
     Filename sanitization
  ----------------------------- */
  const sanitize = (value) =>
    String(value || "unknown")
      .trim()
      .replace(/\s+/g, "")
      .replace(/[^a-zA-Z0-9._-]/g, "_");

  const filename = `${timestamp}_${sanitize(contact)}_${sanitize(
    UserInfoFirstName
  )}_${sanitize(CmpnName)}.json`;

  /* -----------------------------
     Schema hydration
  ----------------------------- */
  const data = Object.fromEntries(schemaNames.map((name) => [name, null]));

  /* -----------------------------
     Overlay actual survey values (STRICT)
  ----------------------------- */
  const unknownKeys = [];
  for (const [key, value] of Object.entries(rest)) {
    if (key in data) {
      data[key] = value;
    } else {
      unknownKeys.push(key);
    }
  }

  if (unknownKeys.length) {
    unknownKeys.sort();
    throw new Error(
      `preSubmitTransform: incoming survey data contains keys not in registry.generated.json schema: ${unknownKeys.join(
        ", "
      )}`
    );
  }

  /* -----------------------------
     Normalize contact fields (written in schema position)
  ----------------------------- */
  const contactType = Boolean(UserInfoContactType);

  data.UserInfoContactType = contactType;

  data.UserInfoContactTypeEmail =
    contactType === false && typeof UserInfoContactTypeEmail === "string"
      ? UserInfoContactTypeEmail
      : null;

  data.UserInfoContactTypeFacebook =
    contactType === true && typeof UserInfoContactTypeFacebook === "string"
      ? UserInfoContactTypeFacebook
      : null;

  /* -----------------------------
     Final payload
  ----------------------------- */
  const effectiveIso = effectiveDate.toISOString();

  return {
    metadata: {
      filename,

      // Keep both for compatibility; both represent the same effective timestamp.
      submittedAt: effectiveIso,
      completedAt: effectiveIso,

      ...(typeof source === "string" && source ? { source } : {}),

      surveyVersion: "Beta 2026.02.01.01",
    },
    data,
  };
}
