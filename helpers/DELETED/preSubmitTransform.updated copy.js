// helpers/preSubmitTransform.js
//
// Authoritative schema source:
//   - registry.generated.json (generated by merge-surveys.js)
//
// Behavior:
//   - Enforces schema order and null-fills missing fields.
//   - STRICT: throws if incoming survey data contains keys not present in the registry schema
//     (excluding known metadata fields).
//

import registry from "./registry.generated.json";

/**
 * Transforms SurveyJS result JSON prior to submission
 * Enforces schema order and null-fills missing fields.
 *
 * @param {object} surveyData - Raw SurveyJS data object
 * @returns {object} Transformed payload with metadata + schema-aligned data
 */
export function preSubmitTransform(surveyData) {
  if (!surveyData || typeof surveyData !== "object") {
    throw new Error("preSubmitTransform: invalid survey data");
  }

  if (!Array.isArray(registry) || registry.length === 0) {
    throw new Error(
      "preSubmitTransform: registry.generated.json is missing or empty (expected an array of {name,...})."
    );
  }

  const schemaNames = registry
    .map((item) => item?.name)
    .filter((name) => typeof name === "string" && name.trim().length > 0);

  if (schemaNames.length === 0) {
    throw new Error(
      "preSubmitTransform: registry.generated.json contains no valid 'name' fields."
    );
  }

  // Extract known non-survey fields (metadata / helpers)
  const {
    UserInfoContactType,
    UserInfoContactTypeEmail,
    UserInfoContactTypeFacebook,
    UserInfoFirstName,
    CmpnName,

    // timestamp compatibility: prefer submittedAt if present
    submittedAt,
    completedAt,

    // optional helper metadata (safe to ignore)
    source,
    _meta,

    ...rest
  } = surveyData;

  /* -----------------------------
     Resolve contact identifier
     (used for filename only)
  ----------------------------- */
  const contact =
    UserInfoContactType === true
      ? UserInfoContactTypeFacebook
      : UserInfoContactTypeEmail || "unknown";

  /* -----------------------------
     Timestamp handling
     - Prefer submittedAt (shared between save + email)
     - Fall back to completedAt
     - Else: now
  ----------------------------- */
  const effectiveDate = submittedAt
    ? new Date(submittedAt)
    : completedAt
    ? new Date(completedAt)
    : new Date();

  if (Number.isNaN(effectiveDate.getTime())) {
    throw new Error(
      "preSubmitTransform: invalid submittedAt/completedAt timestamp (expected ISO string or Date-parsable value)."
    );
  }

  const pad = (n) => String(n).padStart(2, "0");

  // Filename stamp includes seconds (YYYYMMDD_HHMMSS)
  const timestamp = `${effectiveDate.getFullYear()}${pad(
    effectiveDate.getMonth() + 1
  )}${pad(effectiveDate.getDate())}_${pad(effectiveDate.getHours())}${pad(
    effectiveDate.getMinutes()
  )}${pad(effectiveDate.getSeconds())}`;

  /* -----------------------------
     Filename sanitization
  ----------------------------- */
  const sanitize = (value) =>
    String(value || "unknown")
      .trim()
      .replace(/\s+/g, "")
      .replace(/[^a-zA-Z0-9._-]/g, "_");

  const filename = `${timestamp}_${sanitize(contact)}_${sanitize(
    UserInfoFirstName
  )}_${sanitize(CmpnName)}.json`;

  /* -----------------------------
     Schema hydration
     (single source of truth: registry.generated.json)
  ----------------------------- */
  const data = Object.fromEntries(schemaNames.map((name) => [name, null]));

  /* -----------------------------
     Overlay actual survey values (STRICT)
  ----------------------------- */
  const unknownKeys = [];
  for (const [key, value] of Object.entries(rest)) {
    if (key in data) {
      data[key] = value;
    } else {
      unknownKeys.push(key);
    }
  }

  if (unknownKeys.length) {
    // This usually means: you added/renamed questions in page JSON but didn't rebuild registry.generated.json.
    unknownKeys.sort();
    throw new Error(
      `preSubmitTransform: incoming survey data contains keys not in registry.generated.json: ${unknownKeys.join(
        ", "
      )}`
    );
  }

  /* -----------------------------
     Normalize contact fields
     (written in schema position)
  ----------------------------- */
  const contactType = Boolean(UserInfoContactType);

  data.UserInfoContactType = contactType;

  data.UserInfoContactTypeEmail =
    contactType === false && typeof UserInfoContactTypeEmail === "string"
      ? UserInfoContactTypeEmail
      : null;

  data.UserInfoContactTypeFacebook =
    contactType === true && typeof UserInfoContactTypeFacebook === "string"
      ? UserInfoContactTypeFacebook
      : null;

  /* -----------------------------
     Final payload
  ----------------------------- */
  const effectiveIso = effectiveDate.toISOString();

  return {
    metadata: {
      filename,

      // Keep both for compatibility; both represent the same effective timestamp.
      submittedAt: effectiveIso,
      completedAt: effectiveIso,

      // Optional, if you want to trace which component generated it.
      ...(typeof source === "string" && source ? { source } : {}),

      surveyVersion: "Beta 2026.02.01.01",
    },
    data,
  };
}
